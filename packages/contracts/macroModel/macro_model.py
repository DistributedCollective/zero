# -*- coding: utf-8 -*-
"""Baseline vs Alternative V2 Copy

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NNPdiKfO3950MuAGyIXTNrr4OMliINKb

# Parameters and Initialization
"""

import random
import numpy as np
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
import matplotlib.pyplot as plt
import scipy.stats
from plotly.subplots import make_subplots

#policy functions
rate_issuance = 0.01
rate_redemption = 0.01
base_rate_initial = 0

#global variables
period = 24*365
month=24*30
day=24

#bitcoin price
price_BTC_initial = 1000
price_BTC = [price_BTC_initial]
sd_BTC=0.02
drift_BTC = 0

#ZERO price & airdrop
price_ZERO_initial = 1
price_ZERO = [price_ZERO_initial]
sd_ZERO=0.005
drift_ZERO = 0.0035
#reduced for now. otherwise the initial return too high
quantity_ZERO_airdrop = 500
supply_ZERO=[0]
ZERO_total_supply=100000000

#PE ratio
PE_ratio = 50

#natural rate
natural_rate_initial = 0.2
natural_rate = [natural_rate_initial]
sd_natural_rate=0.002

#stability pool
initial_return=0.2
return_stability=[initial_return]
sd_return=0.001
sd_stability=0.001
drift_stability=1.002
theta=0.001

#liquidity pool & redemption pool
sd_liquidity=0.001
sd_redemption=0.001
drift_liquidity=1.0003
redemption_star = 0.8
delta = -20

#close locs
sd_closelocs=0.5
#sensitivity to ZUSD price
beta = 0.2

#open locs
distribution_parameter1_BTC_quantity=10
distribution_parameter2_BTC_quantity=500
distribution_parameter1_CR = 1.1
distribution_parameter2_CR = 0.1
distribution_parameter3_CR = 16
distribution_parameter1_inattention = 4
distribution_parameter2_inattention = 0.08
sd_openlocs=0.5
n_steady=0.5
initial_open=10

#sensitivity to ZUSD price & issuance fee
alpha = 0.3

#number of runs in simulation
n_sim= 8640

"""# Exogenous Factors

Bitcoin Price
"""

#Bitcoin price
for i in range(1, period):
  random.seed(2019375+10000*i)
  shock_BTC = random.normalvariate(0,sd_BTC)
  price_BTC.append(price_BTC[i-1]*(1+shock_BTC)*(1+drift_BTC))

"""Natural Rate"""

#natural rate
for i in range(1, period):
  random.seed(201597+10*i)
  shock_natural = random.normalvariate(0,sd_natural_rate)
  natural_rate.append(natural_rate[i-1]*(1+shock_natural))

"""ZERO Price - First Month"""

#ZERO price
for i in range(1, month):
  random.seed(2+13*i)
  shock_ZERO = random.normalvariate(0,sd_ZERO)  
  price_ZERO.append(price_ZERO[i-1]*(1+shock_ZERO)*(1+drift_ZERO))

"""# LoCs

Liquidate LoCs
"""

def liquidate_locs(locs, index, data):
  locs['CR_current'] = locs['BTC_Price']*locs['BTC_Quantity']/locs['Supply']
  price_ZUSD_previous = data.loc[index-1,'Price_ZUSD']
  price_ZERO_previous = data.loc[index-1,'price_ZERO']
  stability_pool_previous = data.loc[index-1, 'stability']

  locs_liquidated = locs[locs.CR_current < 1.1]
  locs = locs[locs.CR_current >= 1.1]
  debt_liquidated = locs_liquidated['Supply'].sum()
  BTC_liquidated = locs_liquidated['BTC_Quantity'].sum()
  n_liquidate = locs_liquidated.shape[0]
  locs = locs.reset_index(drop = True)

  liquidation_gain = BTC_liquidated*price_BTC_current - debt_liquidated*price_ZUSD_previous
  airdrop_gain = price_ZERO_previous * quantity_ZERO_airdrop
  
  np.random.seed(2+index)
  shock_return = np.random.normal(0,sd_return)
  if index <= day:
   return_stability = initial_return*(1+shock_return)
  elif index<=month:
    #min function to rule out the large fluctuation caused by the large but temporary liquidation gain in a particular period
    return_stability = min(0.5, 365*(data.loc[index-day:index, 'liquidation_gain'].sum()+data.loc[index-day:index, 'airdrop_gain'].sum())/(price_ZUSD_previous*stability_pool_previous))
  else:
    return_stability = (365/30)*(data.loc[index-month:index, 'liquidation_gain'].sum()+data.loc[index-month:index, 'airdrop_gain'].sum())/(price_ZUSD_previous*stability_pool_previous)
  
  return[locs, return_stability, debt_liquidated, BTC_liquidated, liquidation_gain, airdrop_gain, n_liquidate]

"""Close LoCs"""

def close_locs(locs, index2, price_ZUSD_previous):
  np.random.seed(208+index2)
  shock_closelocs = np.random.normal(0,sd_closelocs)
  n_locs = locs.shape[0]

  if index2 <= 240:
    number_closelocs = np.random.uniform(0,1)
  elif price_ZUSD_previous >=1:
    number_closelocs = max(0, n_steady * (1+shock_closelocs))
  else:
    number_closelocs = max(0, n_steady * (1+shock_closelocs)) + beta*(1-price_ZUSD_previous)*n_locs
  
  number_closelocs = int(round(number_closelocs))
  
  random.seed(293+100*index2)
  drops = list(random.sample(range(len(locs)), number_closelocs))
  locs = locs.drop(drops)
  locs = locs.reset_index(drop=True)
  if len(locs) < number_closelocs:
    number_closelocs = -999

  return[locs, number_closelocs]

"""Adjust LoCs"""

def adjust_locs(locs, index):
  issuance_ZUSD_adjust = 0
  random.seed(57984-3*index)
  ratio = random.uniform(0,1)
  for i in range(0, locs.shape[0]):
    random.seed(187*index + 3*i)
    working_loc = locs.iloc[i,:]
    p = random.uniform(0,1)
    check = (working_loc['CR_current']-working_loc['CR_initial'])/(working_loc['CR_initial']*working_loc['Rational_inattention'])

  #A part of the locs are adjusted by adjusting debt
    if p >= ratio:
      if check<-1:
        working_loc['Supply'] = working_loc['BTC_Price']*working_loc['BTC_Quantity']/working_loc['CR_initial']
      if check>2:
        supply_new = working_loc['BTC_Price']*working_loc['BTC_Quantity']/working_loc['CR_initial']
        issuance_ZUSD_adjust = issuance_ZUSD_adjust + rate_issuance * (supply_new - working_loc['Supply'])
        working_loc['Supply'] = supply_new
  #Another part of the locs are adjusted by adjusting collaterals
    if p < ratio and (check < -1 or check > 2):
      working_loc['BTC_Quantity'] = working_loc['CR_initial']*working_loc['Supply']/working_loc['BTC_Price']
    
    locs.loc[i] = working_loc
  return[locs, issuance_ZUSD_adjust]

"""Open LoCs"""

def open_locs(locs, index1, price_ZUSD_previous):
  random.seed(2019*index1)  
  issuance_ZUSD_open = 0
  shock_openlocs = random.normalvariate(0,sd_openlocs)
  n_locs = locs.shape[0]

  if index1<=0:
    number_openlocs = initial_open
  elif price_ZUSD_previous <=1 + rate_issuance:
    number_openlocs = max(0, n_steady * (1+shock_openlocs))
  else:
    number_openlocs = max(0, n_steady * (1+shock_openlocs)) + alpha*(price_ZUSD_previous-rate_issuance-1)*n_locs
  
  number_openlocs = int(round(float(number_openlocs)))

  for i in range(0, number_openlocs):
    price_BTC_current = price_BTC[index1]
    
    np.random.seed(2033 + index1 + i*i)
    CR_ratio = distribution_parameter1_CR + distribution_parameter2_CR * np.random.chisquare(df=distribution_parameter3_CR)
    
    np.random.seed(20 + 10 * i + index1)
    quantity_BTC = np.random.gamma(distribution_parameter1_BTC_quantity, scale=distribution_parameter2_BTC_quantity)
    
    np.random.seed(209870- index1 + i*i)
    rational_inattention = np.random.gamma(distribution_parameter1_inattention, scale=distribution_parameter2_inattention)
    
    supply_loc = price_BTC_current * quantity_BTC / CR_ratio
    issuance_ZUSD_open = issuance_ZUSD_open + rate_issuance * supply_loc

    new_row = {"BTC_Price": price_BTC_current, "BTC_Quantity": quantity_BTC, 
               "CR_initial": CR_ratio, "Supply": supply_loc, 
               "Rational_inattention": rational_inattention, "CR_current": CR_ratio}
    locs = locs.append(new_row, ignore_index=True)

  return[locs, number_openlocs, issuance_ZUSD_open]

"""# ZUSD Market

Stability Pool
"""

def stability_update(stability_pool_previous, return_previous, index):
  np.random.seed(27+3*index)
  shock_stability = np.random.normal(0,sd_stability)
  natural_rate_current = natural_rate[index]
  if index <= month:
    stability_pool = stability_pool_previous* (drift_stability+shock_stability)* (1+ return_previous- natural_rate_current)**theta
  else:
    stability_pool = stability_pool_previous* (1+shock_stability)* (1+ return_previous- natural_rate_current)**theta
  return[stability_pool]

"""ZUSD Price, liquidity pool, and redemption"""

def price_stabilizer(locs, index, data, stability_pool, n_open):
  issuance_ZUSD_stabilizer = 0
  redemption_fee = 0
  n_redempt = 0
  redempted = 0
  redemption_pool = 0  
#Calculating Price
  supply = locs['Supply'].sum()
  np.random.seed(20*index)
  shock_liquidity = np.random.normal(0,sd_liquidity)
  liquidity_pool_previous = float(data['liquidity'][index-1])
  price_ZUSD_previous = float(data['Price_ZUSD'][index-1])
  price_ZUSD_current= price_ZUSD_previous*((supply-stability_pool)/(liquidity_pool_previous*(drift_liquidity+shock_liquidity)))**(1/delta)
  

#Liquidity Pool
  liquidity_pool = supply-stability_pool

#Stabilizer
  #Ceiling Arbitrageurs
  if price_ZUSD_current > 1.1 + rate_issuance:
    #supply_current = sum(locs['Supply'])
    supply_wanted=stability_pool+liquidity_pool_previous*(drift_liquidity+shock_liquidity)*((1.1+rate_issuance)/price_ZUSD_previous)**delta
    supply_loc = supply_wanted - supply

    CR_ratio = 1.1
    rational_inattention = 0.1
    quantity_BTC = supply_loc * CR_ratio / price_BTC_current
    issuance_ZUSD_stabilizer = rate_issuance * supply_loc

    new_row = {"BTC_Price": price_BTC_current, "BTC_Quantity": quantity_BTC, "CR_initial": CR_ratio,
               "Supply": supply_loc, "Rational_inattention": rational_inattention, "CR_current": CR_ratio}
    locs = locs.append(new_row, ignore_index=True)
    price_ZUSD_current = 1.1 + rate_issuance
    #missing in the previous version  
    liquidity_pool = supply_wanted-stability_pool
    n_open=n_open+1
    

  #Floor Arbitrageurs
  if price_ZUSD_current < 1 - rate_redemption:
    np.random.seed(30*index)
    shock_redemption = np.random.normal(0,sd_redemption)
    redemption_ratio = redemption_star * (1+shock_redemption)

    #supply_current = sum(locs['Supply'])
    supply_target=stability_pool+liquidity_pool_previous*(drift_liquidity+shock_liquidity)*((1-rate_redemption)/price_ZUSD_previous)**delta
    supply_diff = supply - supply_target
    if supply_diff < redemption_ratio * liquidity_pool:
      redemption_pool=supply_diff
      #liquidity_pool = liquidity_pool - redemption_pool
      price_ZUSD_current = 1 - rate_redemption
    else:
      redemption_pool=redemption_ratio * liquidity_pool
      #liquidity_pool = (1-redemption_ratio)*liquidity_pool
      price_ZUSD_current= price_ZUSD_previous * (liquidity_pool/(liquidity_pool_previous*(drift_liquidity+shock_liquidity)))**(1/delta)
    
    #Shutting down the riskiest locs
    locs = locs.sort_values(by='CR_current', ascending = True)
    quantity_working_loc = locs['Supply'][locs.index[0]]
    redempted = quantity_working_loc
    while redempted <= redemption_pool:
      locs = locs.drop(locs.index[0])
      quantity_working_loc = locs['Supply'][locs.index[0]]
      redempted = redempted + quantity_working_loc
      n_redempt = n_redempt + 1
    
    #Residuals
    redempted = redempted - quantity_working_loc
    residual = redemption_pool - redempted
    wk = locs.index[0]
    locs['Supply'][wk] = locs['Supply'][wk] - residual
    locs['BTC_Quantity'][wk] = locs['BTC_Quantity'][wk] - residual/price_BTC_current
    locs['CR_current'][wk] = price_BTC_current * locs['BTC_Quantity'][wk] / locs['Supply'][wk]

    #Redemption Fee
    redemption_fee = rate_redemption * redemption_pool
    

  locs = locs.reset_index(drop=True)
  return[price_ZUSD_current, liquidity_pool, locs, issuance_ZUSD_stabilizer, redemption_fee, n_redempt, redemption_pool, n_open]

"""# ZERO Market"""



def ZERO_market(index, data):
  quantity_ZERO = (100000000/3)*(1-0.5**(index/period))
  np.random.seed(2+3*index)
  if index <= month: 
    price_ZERO_current = price_ZERO[index-1]
    annualized_earning = (index/month)**0.5*np.random.normal(200000000,500000)
  else:
    revenue_issuance = data.loc[index-month:index, 'issuance_fee'].sum()
    revenue_redemption = data.loc[index-month:index, 'redemption_fee'].sum()
    annualized_earning = 365*(revenue_issuance+revenue_redemption)/30
    #discountin factor to factor in the risk in early days
    discount=index/period
    price_ZERO_current = discount*PE_ratio*annualized_earning/ZERO_total_supply
  
  MC_ZERO_current = price_ZERO_current * quantity_ZERO
  return[price_ZERO_current, annualized_earning, MC_ZERO_current]

"""# Simulation Program"""

#Defining Initials
initials = {"Price_ZUSD":[1.00], "Price_BTC":[price_BTC_initial], "n_open":[initial_open], "n_close":[0], "n_liquidate": [0], "n_redempt":[0], 
            "n_locs":[initial_open], "stability":[0], "liquidity":[0], "redemption_pool":[0],
            "supply_ZUSD":[0],  "return_stability":[initial_return], "airdrop_gain":[0], "liquidation_gain":[0],  "issuance_fee":[0], "redemption_fee":[0],
            "price_ZERO":[price_ZERO_initial], "MC_ZERO":[0], "annualized_earning":[0]}
data = pd.DataFrame(initials)
locs= pd.DataFrame({"BTC_Price":[], "BTC_Quantity":[], "CR_initial":[], 
              "Supply":[], "Rational_inattention":[], "CR_current":[]})
result_open = open_locs(locs, 0, data['Price_ZUSD'][0])
locs = result_open[0]
issuance_ZUSD_open = result_open[2]
data.loc[0,'issuance_fee'] = issuance_ZUSD_open * initials["Price_ZUSD"][0]
data.loc[0,'supply_ZUSD'] = locs["Supply"].sum()
data.loc[0,'liquidity'] = 0.5*locs["Supply"].sum()
data.loc[0,'stability'] = 0.5*locs["Supply"].sum()

#Simulation Process
for index in range(1, n_sim):
#exogenous BTC price input
  price_BTC_current = price_BTC[index]
  locs['BTC_Price'] = price_BTC_current
  price_ZUSD_previous = data.loc[index-1,'Price_ZUSD']
  price_ZERO_previous = data.loc[index-1,'price_ZERO']

#LoC liquidation & return of stability pool
  result_liquidation = liquidate_locs(locs, index, data)
  locs = result_liquidation[0]
  return_stability = result_liquidation[1]
  debt_liquidated = result_liquidation[2]
  BTC_liquidated = result_liquidation[3]
  liquidation_gain = result_liquidation[4]
  airdrop_gain = result_liquidation[5]
  n_liquidate = result_liquidation[6]

#close locs
  result_close = close_locs(locs, index, price_ZUSD_previous)
  locs = result_close[0]
  n_close = result_close[1]
  #if n_close<0:
  #  break

#adjust locs
  result_adjustment = adjust_locs(locs, index)
  locs = result_adjustment[0]
  issuance_ZUSD_adjust = result_adjustment[1]

#open locs
  result_open = open_locs(locs, index, price_ZUSD_previous)
  locs = result_open[0]
  n_open = result_open[1]  
  issuance_ZUSD_open = result_open[2]

#Stability Pool
  stability_pool = stability_update(data.loc[index-1,'stability'], return_stability, index)[0]

#Calculating Price, Liquidity Pool, and Redemption
  result_price = price_stabilizer(locs, index, data, stability_pool, n_open)
  price_ZUSD_current = result_price[0]
  liquidity_pool = result_price[1]
  locs = result_price[2]
  issuance_ZUSD_stabilizer = result_price[3]
  redemption_fee = result_price[4]
  n_redempt = result_price[5]
  redemption_pool = result_price[6]
  n_open=result_price[7]
  if liquidity_pool<0:
    break

#ZERO Market
  result_ZERO = ZERO_market(index, data)
  price_ZERO_current = result_ZERO[0]
  annualized_earning = result_ZERO[1]
  MC_ZERO_current = result_ZERO[2]

#Summary
  issuance_fee = price_ZUSD_current * (issuance_ZUSD_adjust + issuance_ZUSD_open + issuance_ZUSD_stabilizer)
  n_locs = locs.shape[0]
  supply_ZUSD = locs['Supply'].sum()
  if index >= month:
    price_ZERO.append(price_ZERO_current)

  new_row = {"Price_ZUSD":float(price_ZUSD_current), "Price_BTC":float(price_BTC_current), "n_open":float(n_open), "n_close":float(n_close), 
             "n_liquidate":float(n_liquidate), "n_redempt": float(n_redempt), "n_locs":float(n_locs),
              "stability":float(stability_pool), "liquidity":float(liquidity_pool), "redemption_pool":float(redemption_pool), "supply_ZUSD":float(supply_ZUSD),
             "issuance_fee":float(issuance_fee), "redemption_fee":float(redemption_fee),
             "airdrop_gain":float(airdrop_gain), "liquidation_gain":float(liquidation_gain), "return_stability":float(return_stability), 
             "annualized_earning":float(annualized_earning), "MC_ZERO":float(MC_ZERO_current), "price_ZERO":float(price_ZERO_current)
             }
  data = data.append(new_row, ignore_index=True)
  if price_ZUSD_current < 0:
    break

"""#**Exhibition**"""

data

def linevis(data, measure):
  fig = px.line(data, x=data.index/720, y=measure, title= measure+' dynamics')
  fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['Price_ZUSD'], name="ZUSD Price"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['Price_BTC'], name="BTC Price"),
    secondary_y=True,
)
fig.update_layout(
    title_text="Price Dynamics of ZUSD and Bitcoin"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="ZUSD Price", secondary_y=False)
fig.update_yaxes(title_text="BTC Price", secondary_y=True)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['n_locs'], name="Number of LoCs"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['supply_ZUSD'], name="ZUSD Supply"),
    secondary_y=True,
)
fig.update_layout(
    title_text="Dynamics of LoC Numbers and ZUSD Supply"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Number of LoCs", secondary_y=False)
fig.update_yaxes(title_text="ZUSD Supply", secondary_y=True)
fig.show()

fig = make_subplots(rows=2, cols=1)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['n_open'], name="Number of LoCs Opened", mode='markers'),
    row=1, col=1, secondary_y=False
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['n_close'], name="Number of LoCs Closed", mode='markers'),
    row=2, col=1, secondary_y=False
)
fig.update_layout(
    title_text="Dynamics of Number of LoCs Opened and Closed"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="LoCs Opened", row=1, col=1)
fig.update_yaxes(title_text="LoCs Closed", row=2, col=1)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['n_liquidate'], name="Number of Liquidated LoCs", mode='markers'),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['n_redempt'], name="Number of Redempted LoCs", mode='markers'),
    secondary_y=False,
)
fig.update_layout(
    title_text="Dynamics of Number of Liquidated and Redempted LoCs"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Number of Liquidated LoCs", secondary_y=False)
fig.update_yaxes(title_text="Number of Redempted LoCs", secondary_y=True)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['liquidity'], name="Liquidity Pool"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['stability'], name="Stability Pool"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=100*data['redemption_pool'], name="100*Redemption Pool"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['return_stability'], name="Return of Stability Pool"),
    secondary_y=True,
)
fig.update_layout(
    title_text="Dynamics of Liquidity, Stability, Redemption Pools and Return of Stability Pool"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Size of Pools", secondary_y=False)
fig.update_yaxes(title_text="Return", secondary_y=True)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['airdrop_gain'], name="Airdrop Gain"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['liquidation_gain'], name="Liquidation Gain"),
    secondary_y=True,
)
fig.update_layout(
    title_text="Dynamics of Airdrop and Liquidation Gain"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Airdrop Gain", secondary_y=False)
fig.update_yaxes(title_text="Liquidation Gain", secondary_y=True)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['issuance_fee'], name="Issuance Fee"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['redemption_fee'], name="Redemption Fee"),
    secondary_y=True,
)
fig.update_layout(
    title_text="Dynamics of Issuance Fee and Redemption Fee"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Issuance Fee", secondary_y=False)
fig.update_yaxes(title_text="Redemption Fee", secondary_y=True)
fig.show()

#linevis(data, 'annualized_earning')

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['price_ZERO'], name="ZERO Price"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['MC_ZERO'], name="ZERO Market Cap"),
    secondary_y=True,
)
fig.update_layout(
    title_text="Dynamics of the Price and Market Cap of ZERO"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="ZERO Price", secondary_y=False)
fig.update_yaxes(title_text="ZERO Market Cap", secondary_y=True)
fig.show()

def loc_histogram(measure):
  fig = px.histogram(locs, x=measure, title='Distribution of '+measure, nbins=25)
  fig.show()

locs

loc_histogram('BTC_Quantity')
loc_histogram('CR_initial')
loc_histogram('Supply')
loc_histogram('Rational_inattention')
loc_histogram('CR_current')

import matplotlib.pyplot as plt
plt.plot(locs["BTC_Quantity"])
plt.show()

plt.plot(locs["CR_initial"])
plt.show()

plt.plot(locs["Supply"])
plt.show()

plt.plot(locs["CR_current"])
plt.show()

data.describe()

"""new policy function

issuance fee = redemption fee = base rate

#**Simulation with Policy Function**
"""

#Defining Initials
initials = {"Price_ZUSD":[1.00], "Price_BTC":[price_BTC_initial], "n_open":[initial_open], "n_close":[0], "n_liquidate": [0], "n_redempt":[0], 
            "n_locs":[initial_open], "stability":[0], "liquidity":[0], "redemption_pool":[0],
            "supply_ZUSD":[0],  "return_stability":[initial_return], "airdrop_gain":[0], "liquidation_gain":[0],  "issuance_fee":[0], "redemption_fee":[0],
            "price_ZERO":[price_ZERO_initial], "MC_ZERO":[0], "annualized_earning":[0], "base_rate":[base_rate_initial]}
data2 = pd.DataFrame(initials)
locs2= pd.DataFrame({"BTC_Price":[], "BTC_Quantity":[], "CR_initial":[], 
              "Supply":[], "Rational_inattention":[], "CR_current":[]})
result_open = open_locs(locs2, 0, data2['Price_ZUSD'][0])
locs2 = result_open[0]
issuance_ZUSD_open = result_open[2]
data2.loc[0,'issuance_fee'] = issuance_ZUSD_open * initials["Price_ZUSD"][0]
data2.loc[0,'supply_ZUSD'] = locs2["Supply"].sum()
data2.loc[0,'liquidity'] = 0.5*locs2["Supply"].sum()
data2.loc[0,'stability'] = 0.5*locs2["Supply"].sum()

#Simulation Process
for index in range(1, n_sim):
#exogenous BTC price input
  price_BTC_current = price_BTC[index]
  locs2['BTC_Price'] = price_BTC_current
  price_ZUSD_previous = data2.loc[index-1,'Price_ZUSD']
  price_ZERO_previous = data2.loc[index-1,'price_ZERO']

#policy function determines base rate
  base_rate_current = 0.98 * data2.loc[index-1,'base_rate'] + 0.5*(data2.loc[index-1,'redemption_pool']/locs2['Supply'].sum())
  rate_issuance = base_rate_current
  rate_redemption = base_rate_current

#LoC liquidation & return of stability pool
  result_liquidation = liquidate_locs(locs2, index, data2)
  locs2 = result_liquidation[0]
  return_stability = result_liquidation[1]
  debt_liquidated = result_liquidation[2]
  BTC_liquidated = result_liquidation[3]
  liquidation_gain = result_liquidation[4]
  airdrop_gain = result_liquidation[5]
  n_liquidate = result_liquidation[6]

#close locs
  result_close = close_locs(locs2, index, price_ZUSD_previous)
  locs2 = result_close[0]
  n_close = result_close[1]
  #if n_close<0:
  #  break

#adjust locs
  result_adjustment = adjust_locs(locs2, index)
  locs2 = result_adjustment[0]
  issuance_ZUSD_adjust = result_adjustment[1]

#open locs
  result_open = open_locs(locs2, index, price_ZUSD_previous)
  locs2 = result_open[0]
  n_open = result_open[1]  
  issuance_ZUSD_open = result_open[2]

#Stability Pool
  stability_pool = stability_update(data2.loc[index-1,'stability'], return_stability, index)[0]

#Calculating Price, Liquidity Pool, and Redemption
  result_price = price_stabilizer(locs2, index, data2, stability_pool, n_open)
  price_ZUSD_current = result_price[0]
  liquidity_pool = result_price[1]
  locs2 = result_price[2]
  issuance_ZUSD_stabilizer = result_price[3]
  redemption_fee = result_price[4]
  n_redempt = result_price[5]
  redemption_pool = result_price[6]
  n_open=result_price[7]
  if liquidity_pool<0:
    break

#ZERO Market
  result_ZERO = ZERO_market(index, data2)
  price_ZERO_current = result_ZERO[0]
  annualized_earning = result_ZERO[1]
  MC_ZERO_current = result_ZERO[2]

#Summary
  issuance_fee = price_ZUSD_current * (issuance_ZUSD_adjust + issuance_ZUSD_open + issuance_ZUSD_stabilizer)
  n_locs = locs2.shape[0]
  supply_ZUSD = locs2['Supply'].sum()
  if index >= month:
    price_ZERO.append(price_ZERO_current)

  new_row = {"Price_ZUSD":float(price_ZUSD_current), "Price_BTC":float(price_BTC_current), "n_open":float(n_open), "n_close":float(n_close), 
             "n_liquidate":float(n_liquidate), "n_redempt": float(n_redempt), "n_locs":float(n_locs),
              "stability":float(stability_pool), "liquidity":float(liquidity_pool), "redemption_pool":float(redemption_pool), "supply_ZUSD":float(supply_ZUSD),
             "issuance_fee":float(issuance_fee), "redemption_fee":float(redemption_fee),
             "airdrop_gain":float(airdrop_gain), "liquidation_gain":float(liquidation_gain), "return_stability":float(return_stability), 
             "annualized_earning":float(annualized_earning), "MC_ZERO":float(MC_ZERO_current), "price_ZERO":float(price_ZERO_current), 
             "base_rate":float(base_rate_current)}
  data2 = data2.append(new_row, ignore_index=True)
  if price_ZUSD_current < 0:
    break

data2

"""#**Exhibition Part 2**"""

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['Price_ZUSD'], name="ZUSD Price"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['Price_BTC'], name="BTC Price"),
    secondary_y=True,
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['Price_ZUSD'], name="ZUSD Price New", line = dict(dash='dot')),
    secondary_y=False,
)
fig.update_layout(
    title_text="Price Dynamics of ZUSD and Bitcoin"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="ZUSD Price", secondary_y=False)
fig.update_yaxes(title_text="BTC Price", secondary_y=True)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['n_locs'], name="Number of LoCs"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['supply_ZUSD'], name="ZUSD Supply"),
    secondary_y=True,
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['n_locs'], name="Number of LoCs New", line = dict(dash='dot')),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['supply_ZUSD'], name="ZUSD Supply New", line = dict(dash='dot')),
    secondary_y=True,
)
fig.update_layout(
    title_text="Dynamics of LoC Numbers and ZUSD Supply"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Number of LoCs", secondary_y=False)
fig.update_yaxes(title_text="ZUSD Supply", secondary_y=True)
fig.show()

fig = make_subplots(rows=2, cols=2)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['n_open'], name="Number of LoCs Opened", mode='markers'),
    row=1, col=1, secondary_y=False
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['n_close'], name="Number of LoCs Closed", mode='markers'),
    row=2, col=1, secondary_y=False
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['n_open'], name="Number of LoCs Opened New", mode='markers'),
    row=1, col=2, secondary_y=False
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['n_close'], name="Number of LoCs Closed New", mode='markers'),
    row=2, col=2, secondary_y=False
)
fig.update_layout(
    title_text="Dynamics of Number of LoCs Opened and Closed"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="LoCs Opened", row=1, col=1)
fig.update_yaxes(title_text="LoCs Closed", row=2, col=1)
fig.show()

fig = make_subplots(rows=2, cols=1)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['n_liquidate'], name="Number of Liquidated LoCs"),
    row=1, col=1, secondary_y=False
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['n_redempt'], name="Number of Redempted LoCs"),
    row=2, col=1, secondary_y=False
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['n_liquidate'], name="Number of Liquidated LoCs New", line = dict(dash='dot')),
    row=1, col=1, secondary_y=False
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['n_redempt'], name="Number of Redempted LoCs New", line = dict(dash='dot')),
    row=2, col=1, secondary_y=False
)
fig.update_layout(
    title_text="Dynamics of Number of Liquidated and Redempted LoCs"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="LoCs Liquidated", row=1, col=1)
fig.update_yaxes(title_text="LoCs Redempted", row=2, col=1)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['liquidity'], name="Liquidity Pool"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['stability'], name="Stability Pool"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=100*data['redemption_pool'], name="100*Redemption Pool"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['liquidity'], name="Liquidity Pool New", line = dict(dash='dot')),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['stability'], name="Stability Pool New", line = dict(dash='dot')),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=100*data2['redemption_pool'], name="100*Redemption Pool New", line = dict(dash='dot')),
    secondary_y=False,
)
fig.update_layout(
    title_text="Dynamics of Liquidity, Stability, Redemption Pools and Return of Stability Pool"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Size of Pools", secondary_y=False)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['return_stability'], name="Return of Stability Pool"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['return_stability'], name="Return of Stability Pool New", line = dict(dash='dot')),
    secondary_y=False,
)
fig.update_layout(
    title_text="Dynamics of Liquidity, Stability, Redemption Pools and Return of Stability Pool"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Return", secondary_y=False)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['airdrop_gain'], name="Airdrop Gain"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['liquidation_gain'], name="Liquidation Gain"),
    secondary_y=True,
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['airdrop_gain'], name="Airdrop Gain New", line = dict(dash='dot')),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['liquidation_gain'], name="Liquidation Gain New", line = dict(dash='dot')),
    secondary_y=True,
)
fig.update_layout(
    title_text="Dynamics of Airdrop and Liquidation Gain"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Airdrop Gain", secondary_y=False)
fig.update_yaxes(title_text="Liquidation Gain", secondary_y=True)
fig.show()

fig = make_subplots(rows=2, cols=1)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['issuance_fee'], name="Issuance Fee"),
    row=1, col=1
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['redemption_fee'], name="Redemption Fee"),
    row=2, col=1
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['issuance_fee'], name="Issuance Fee New", line = dict(dash='dot')),
    row=1, col=1
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['redemption_fee'], name="Redemption Fee New", line = dict(dash='dot')),
    row=2, col=1
)
fig.update_layout(
    title_text="Dynamics of Issuance Fee and Redemption Fee"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Issuance Fee", secondary_y=False, row=1, col=1)
fig.update_yaxes(title_text="Redemption Fee", secondary_y=False, row=2, col=1)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['annualized_earning'], name="Annualized Earning"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['annualized_earning'], name="Annualized Earning New", line = dict(dash='dot')),
    secondary_y=False,
)
fig.update_layout(
    title_text="Dynamics of Annualized Earning"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Annualized Earning", secondary_y=False)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['price_ZERO'], name="ZERO Price"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index/720, y=data['MC_ZERO'], name="ZERO Market Cap"),
    secondary_y=True,
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['price_ZERO'], name="ZERO Price New", line = dict(dash='dot')),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['MC_ZERO'], name="ZERO Market Cap New", line = dict(dash='dot')),
    secondary_y=True,
)
fig.update_layout(
    title_text="Dynamics of the Price and Market Cap of ZERO"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="ZERO Price", secondary_y=False)
fig.update_yaxes(title_text="ZERO Market Cap", secondary_y=True)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index/720, y=[0.01] * n_sim, name="Base Rate"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data2.index/720, y=data2['base_rate'], name="Base Rate New"),
    secondary_y=False,
)
fig.update_layout(
    title_text="Dynamics of Issuance Fee and Redemption Fee"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Issuance Fee", secondary_y=False)
fig.update_yaxes(title_text="Redemption Fee", secondary_y=True)
fig.show()

def loc2_histogram(measure):
  fig = px.histogram(locs2, x=measure, title='Distribution of '+measure, nbins=25)
  fig.show()

loc2_histogram('BTC_Quantity')
loc2_histogram('CR_initial')
loc2_histogram('Supply')
loc2_histogram('Rational_inattention')
loc2_histogram('CR_current')